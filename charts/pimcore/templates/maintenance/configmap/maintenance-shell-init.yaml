apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "pimcore.fullname" . }}-maintenance-shell-init
  labels:
    {{- include "pimcore.labels" . | nindent 4 }}
data:
  entrypoint.sh: |
    #!/usr/bin/env bash
    set -euo pipefail

    # Ensure we have the tools we need:
    # - util-linux: su with --whitelist-environment
    # - bash/coreutils: for arrays, comm, sort, etc.
    # - sudo/acl
    export DEBIAN_FRONTEND=noninteractive
    apt-get update
    apt-get install -y --no-install-recommends \
        bash coreutils procps util-linux sudo acl yq mariadb-client \
        {{ .Values.maintenance.shell.installPackages }}
    # rm -rf /var/lib/apt/lists/*

    maintainer_group_name={{ .Values.maintenance.shell.maintainer.groupName }}
    maintainer_group_id={{ .Values.maintenance.shell.maintainer.groupId }}
    maintainer_user_name={{ .Values.maintenance.shell.maintainer.userName }}
    maintainer_user_id={{ .Values.maintenance.shell.maintainer.userId }}

    if ! getent group "$maintainer_group_name" >/dev/null; then
      addgroup --gid "$maintainer_group_id" "$maintainer_group_name"
      echo "%$maintainer_group_name ALL=(ALL) NOPASSWD:ALL" >> /etc/sudoers
    fi

    if ! id -u "$maintainer_user_name" >/dev/null 2>&1; then
      adduser --disabled-password --gecos "" --uid "$maintainer_user_id" --gid "$maintainer_group_id" "$maintainer_user_name"
    fi

    home="$(eval echo ~"$maintainer_user_name")"

    # Minimal login customizations for the maintainer
    if ! grep -q 'PIMCORE_LOGIN_BOOTSTRAP' "$home/.profile" 2>/dev/null; then
      printf '%s\n' \
        '# PIMCORE_LOGIN_BOOTSTRAP' \
        'export PHP_MAX_EXECUTION_TIME=0' \
        'export PHP_MEMORY_LIMIT=-1' \
        'target_dir=${MAINTAINER_CWD:-/var/www/pimcore}' \
        'if [ -d "$target_dir" ]; then' \
        '  cd "$target_dir" || true' \
        'fi' >> "$home/.profile"
      chown "$maintainer_user_name:$maintainer_group_name" "$home/.profile"
    fi

    # Install helper scripts into PATH (copied from configmap mount)
    install -m 0755 /opt/maintenance-scripts/maint-login-merge.sh /usr/local/bin/maint-login-merge
    install -m 0755 /opt/maintenance-scripts/maint-shell.sh /usr/local/bin/maint-shell
    install -m 0755 /opt/maintenance-scripts/maint-cache-reset.sh /usr/local/bin/maint-cache-reset
    install -m 0755 /opt/maintenance-scripts/maint-graphql-cache-reset.sh /usr/local/bin/maint-graphql-cache-reset
    install -m 0755 /opt/maintenance-scripts/maint-db-import.sh /usr/local/bin/maint-db-import
    install -m 0755 /opt/maintenance-scripts/maint-help /usr/local/bin/maint-help

    {{ .Values.maintenance.shell.entrypointAdditionalCommands | indent 4  }}

    touch /tmp/entrypoint_done

    # Start an interactive login shell for the maintainer with merged env
    # kubectl attach -it deployment/pimcore-maintenance-shell
    exec /usr/local/bin/maint-login-merge "$maintainer_user_name" /var/www/pimcore

  maint-login-merge.sh: |
    #!/usr/bin/env bash
    # Usage: maint-login-merge <user> [cd_target]
    set -euo pipefail

    if [[ $# -lt 1 ]]; then
      echo "Usage: $0 <user> [cd_target]" >&2
      exit 2
    fi

    user="$1"
    cd_target="${2:-}"

    # Get the *names* of variables in the maintainer's true login env
    login_names="$(
      env -i su -l "$user" -s /bin/sh -c 'env | cut -d= -f1 | LC_ALL=C sort -u'
    )"

    # Names in current (container) env
    container_names="$(env | cut -d= -f1 | LC_ALL=C sort -u)"

    # Compute container-only env names (login takes precedence on collisions)
    # Drop noisy session vars; remove the grep if you want literally everything.
    extras_names_raw="$(
      comm -13 \
        <(printf '%s\n' "$login_names") \
        <(printf '%s\n' "$container_names") \
      | grep -Ev '^(PWD|OLDPWD|SHLVL|_)$' || true
    )"

    extras_names_combined="$extras_names_raw"
    if [[ -n "${cd_target}" ]]; then
      export MAINTAINER_CWD="$cd_target"
      extras_names_combined="$(printf '%s\n%s\n' "$extras_names_combined" "MAINTAINER_CWD")"
    fi

    extras_clean="$(printf '%s\n' "$extras_names_combined" | grep -Ev '^\s*$' || true)"

    if [[ -n "$extras_clean" ]]; then
      extras_csv="$(printf '%s\n' "$extras_clean" | LC_ALL=C sort -u | paste -sd, -)"
    else
      extras_csv=""
    fi

    su_args=( -l "$user" --shell /bin/bash )
    if [[ -n "${extras_csv}" ]]; then
      su_args+=( --whitelist-environment="$extras_csv" )
    fi
    exec su "${su_args[@]}"

  # External launcher
  maint-shell.sh: |
    #!/usr/bin/env bash
    # Convenient wrapper to open a new maintainer login shell with merged env
    # You can run: kubectl exec -it deployment/pimcore-maintenance-shell -- maint-shell
    set -euo pipefail
    : "${MAINTAINER_USER_NAME:={{ .Values.maintenance.shell.maintainer.userName }}}"
    : "${MAINTAINER_CWD:=/var/www/pimcore}"
    exec /usr/local/bin/maint-login-merge "$MAINTAINER_USER_NAME" "$MAINTAINER_CWD"

  maint-cache-reset.sh: |
    #!/usr/bin/env bash
    # Reset Pimcore cache: retries cache:clear until it succeeds, then warms cache
    set -euo pipefail

    target_user="${CACHE_RESET_USER:-www-data}"
    memory_limit="${CACHE_RESET_MEMORY_LIMIT:-2G}"
    console_bin="${PIMCORE_CONSOLE_BIN:-bin/console}"
    php_bin="${PHP_BIN:-php}"
    retry_delay="${CACHE_RESET_RETRY_DELAY:-1}"

    cd "/var/www/pimcore" || {
      echo "Failed to change directory to /var/www/pimcore" >&2
      exit 1
    }

    clear_cmd=( sudo -E -u "$target_user" "$php_bin" -d "memory_limit=${memory_limit}" "$console_bin" cache:clear --no-warmup )
    warmup_cmd=( sudo -E -u "$target_user" "$php_bin" -d "memory_limit=${memory_limit}" "$console_bin" cache:warmup )

    while true; do
      if "${clear_cmd[@]}"; then
        break
      fi
      echo "cache:clear failed; retrying in ${retry_delay}s..." >&2
      sleep "$retry_delay"
    done

    "${warmup_cmd[@]}"

  maint-graphql-cache-reset.sh: |
    #!/usr/bin/env bash
    # Reset datahub GraphQL cache
    set -euo pipefail

    target_user="${CACHE_RESET_USER:-www-data}"
    console_bin="${PIMCORE_CONSOLE_BIN:-bin/console}"
    php_bin="${PHP_BIN:-php}"

    cd "/var/www/pimcore" || {
      echo "Failed to change directory to /var/www/pimcore" >&2
      exit 1
    }

    sudo -E -u "$target_user" "$php_bin" "$console_bin" cache:pool:invalidate-tags datahub

  maint-db-import.sh: |
    #!/usr/bin/env bash
    # Import a SQL dump into the Pimcore database, supporting common compression formats.
    set -euo pipefail

    show_usage() {
      printf '%s\n' \
        "Usage: maint-db-import [--dump-file <path>|-f <path>] [--help]" \
        "" \
        "Import a Pimcore database dump from a file or STDIN. Supported compressions:" \
        "plain text, gzip (.gz), bzip2 (.bz2), xz (.xz), and zstd (.zst/.zstd)." \
        "Clears and warms the Pimcore cache after import." \
        "" \
        "Examples:" \
        "  maint-db-import --dump-file /tmp/dump.sql.gz" \
        "  zcat /tmp/dump.sql.gz | maint-db-import" \
        "  kubectl exec -i deployment/pimcore-maintenance-shell -- maint-db-import \\" \
        "    --dump-file /tmp/dump.sql"
    }

    dump_file=""
    while [[ $# -gt 0 ]]; do
      case "$1" in
        --dump-file|-f)
          if [[ $# -lt 2 ]]; then
            echo "Error: $1 requires a path argument." >&2
            show_usage
            exit 2
          fi
          dump_file="$2"
          shift 2
          ;;
        -h|--help)
          show_usage
          exit 0
          ;;
        --)
          shift
          break
          ;;
        *)
          if [[ -z "$dump_file" ]]; then
            dump_file="$1"
            shift
          else
            echo "Error: unexpected argument '$1'." >&2
            show_usage
            exit 2
          fi
          ;;
      esac
    done

    if [[ -z "$dump_file" ]]; then
      if [[ -t 0 ]]; then
        echo "Error: no dump provided via --dump-file and STDIN is not piped." >&2
        show_usage
        exit 2
      fi
      dump_file="-"
    fi

    cleanup_path=""
    if [[ "$dump_file" == "-" ]]; then
      tmp_file="$(mktemp -t pimcore-db-import.XXXXXX)"
      cleanup_path="$tmp_file"
      trap '[[ -n "$cleanup_path" ]] && rm -f "$cleanup_path"' EXIT
      cat > "$tmp_file"
      source_path="$tmp_file"
    else
      source_path="$dump_file"
      if [[ ! -f "$source_path" ]]; then
        echo "Error: dump file '$source_path' not found." >&2
        exit 2
      fi
    fi

    detect_compression() {
      local path="$1"
      if command -v file >/dev/null 2>&1; then
        local mime
        mime="$(file -b --mime-type "$path" 2>/dev/null || true)"
        case "$mime" in
          application/gzip) echo "gzip"; return ;;
          application/x-bzip2) echo "bzip2"; return ;;
          application/x-xz) echo "xz"; return ;;
          application/zstd) echo "zstd"; return ;;
        esac
      fi
      case "$path" in
        *.gz|*.sql.gz|*.tgz) echo "gzip" ;;
        *.bz2|*.sql.bz2|*.tbz2) echo "bzip2" ;;
        *.xz|*.sql.xz) echo "xz" ;;
        *.zst|*.sql.zst|*.zstd) echo "zstd" ;;
        *) echo "plain" ;;
      esac
    }

    compression="$(detect_compression "$source_path")"
    reader_cmd=(cat "$source_path")

    require_cmd() {
      if ! command -v "$1" >/dev/null 2>&1; then
        echo "Error: required command '$1' is not available in PATH." >&2
        exit 4
      fi
    }

    case "$compression" in
      plain)
        reader_cmd=(cat "$source_path")
        ;;
      gzip)
        require_cmd gzip
        reader_cmd=(gzip -cd -- "$source_path")
        ;;
      bzip2)
        require_cmd bzip2
        reader_cmd=(bzip2 -cd -- "$source_path")
        ;;
      xz)
        require_cmd xz
        reader_cmd=(xz -cd -- "$source_path")
        ;;
      zstd)
        require_cmd zstd
        reader_cmd=(zstd -cd -- "$source_path")
        ;;
      *)
        echo "Error: unsupported compression type '$compression'." >&2
        exit 3
        ;;
    esac

    require_cmd yq
    require_cmd mysql

    config_path="${DATABASE_CONFIG_PATH:-/var/www/pimcore/config/local/database.yaml}"
    if [[ ! -f "$config_path" ]]; then
      echo "Error: database config '$config_path' not found." >&2
      exit 2
    fi

    yaml_query_base='.doctrine.dbal.connections.default'
    mysql_host="$(yq -r "${yaml_query_base}.host // empty" "$config_path")"
    mysql_port="$(yq -r "${yaml_query_base}.port // empty" "$config_path")"
    mysql_user="$(yq -r "${yaml_query_base}.user // empty" "$config_path")"
    mysql_password="$(yq -r "${yaml_query_base}.password // empty" "$config_path")"
    mysql_dbname="$(yq -r "${yaml_query_base}.dbname // empty" "$config_path")"

    if [[ -z "$mysql_host" || -z "$mysql_user" || -z "$mysql_password" || -z "$mysql_dbname" ]]; then
      echo "Error: one or more required database settings (host/user/password/dbname) are missing in $config_path." >&2
      exit 1
    fi

    if [[ -z "$mysql_port" || "$mysql_port" == "null" ]]; then
      mysql_port="3306"
    fi

    mysql_cmd=(
      mysql
      --protocol=tcp
      --host="$mysql_host"
      --port="$mysql_port"
      --user="$mysql_user"
      "$mysql_dbname"
    )

    echo "Importing dump into database '$mysql_dbname' at ${mysql_host}:${mysql_port}..." >&2
    if ! "${reader_cmd[@]}" | MYSQL_PWD="$mysql_password" "${mysql_cmd[@]}"; then
      echo "Error: database import failed." >&2
      exit 1
    fi
    echo "Database import completed successfully." >&2
    echo "Resetting Pimcore cache..." >&2
    /usr/local/bin/maint-cache-reset
    echo "Pimcore cache reset completed." >&2

  maint-help: |
    #!/usr/bin/env bash
    # Show help for maintenance shell usage
    set -euo pipefail

    cat <<'EOF'
    Pimcore Maintenance Shell Help

    This container provides a maintenance shell environment for Pimcore.

    Available commands:

    - maint-shell
      Opens an interactive login shell as the maintainer user with merged environment variables.

    - maint-cache-reset
      Resets the Pimcore cache by repeatedly attempting to clear it until successful, then warms the cache.

    - maint-graphql-cache-reset
      Resets the Datahub GraphQL cache.

    - maint-db-import
      Imports a SQL dump into the Pimcore database; accepts --dump-file or reads from STDIN and handles common compression formats.

    Usage Examples:

    To open a maintenance shell:
      kubectl exec -it deployment/pimcore-maintenance-shell -- maint-shell

    To reset Pimcore cache:
      kubectl exec -it deployment/pimcore-maintenance-shell -- maint-cache-reset

    To reset Datahub GraphQL cache:
      kubectl exec -it deployment/pimcore-maintenance-shell -- maint-graphql-cache-reset

    To import a database dump (and clear the cache afterward):
      kubectl exec -i deployment/pimcore-maintenance-shell -- maint-db-import --help
      kubectl exec -i deployment/pimcore-maintenance-shell -- maint-db-import --dump-file /tmp/dump.sql.gz
      cat /tmp/dump.sql.xz | kubectl exec -i deployment/pimcore-maintenance-shell -- maint-db-import

    Note: -it flags are recommended for interactive commands and colored output.

    EOF
